# Глава 3: Параллелизация

## Обзор паттерна

Параллелизация — одновременное выполнение нескольких компонентов (вызовы LLM, инструменты, подагенты) для сокращения общего времени выполнения. Вместо последовательного ожидания независимые задачи запускаются одновременно.

**Последовательный подход:**
1. Найти источник A → Суммировать A → Найти источник B → Суммировать B → Синтез

**Параллельный подход:**
1. Найти A и B одновременно
2. Суммировать A и B одновременно
3. Синтез (последовательно)

Фреймворки LangChain, LangGraph и Google ADK поддерживают асинхронное исполнение для параллелизации.

## Практические применения

1. **Сбор информации:** Одновременный поиск в новостях, биржевых данных, соцсетях и внутренней базе

2. **Обработка данных:** Параллельный сентимент-анализ, извлечение ключевых слов, категоризация отзывов

3. **Множественные API:** Одновременная проверка авиабилетов, отелей, событий, ресторанов

4. **Генерация контента:** Параллельная генерация темы письма, текста, изображения, CTA

5. **Валидация:** Одновременная проверка email, телефона, адреса, ненормативной лексики

6. **Мультимодальность:** Параллельный анализ текста и изображения

7. **A/B-тестирование:** Генерация нескольких вариантов с разными промптами

## Практический пример кода

```python
import asyncio
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from langchain_core.runnables import RunnableParallel, RunnablePassthrough

llm = ChatOpenAI(model="gpt-4o-mini", temperature=0.7)

# Три независимые цепочки
summarize_chain = (
    ChatPromptTemplate.from_messages([
        ("system", "Summarize the topic concisely:"),
        ("user", "{topic}")
    ]) | llm | StrOutputParser()
)

questions_chain = (
    ChatPromptTemplate.from_messages([
        ("system", "Generate 3 questions about:"),
        ("user", "{topic}")
    ]) | llm | StrOutputParser()
)

terms_chain = (
    ChatPromptTemplate.from_messages([
        ("system", "Extract 5-10 key terms:"),
        ("user", "{topic}")
    ]) | llm | StrOutputParser()
)

# Параллельная карта
map_chain = RunnableParallel(
    summary=summarize_chain,
    questions=questions_chain,
    terms=terms_chain,
    original_topic=RunnablePassthrough()
)

# Синтез результатов
synthesis_prompt = ChatPromptTemplate.from_template(
    """Topic: {original_topic}
    Summary: {summary}
    Questions: {questions}
    Terms: {terms}
    
    Provide comprehensive response."""
)

full_chain = map_chain | synthesis_prompt | llm | StrOutputParser()

# Выполнение
async def run_example(topic: str):
    response = await full_chain.ainvoke(topic)
    print(response)

asyncio.run(run_example("История космических исследований"))
```

**Примечание:** `asyncio` обеспечивает конкурентность на одном потоке (не истинный параллелизм), но эффективен при I/O-операциях.

## Ключевые выводы

- Параллелизация ускоряет выполнение независимых подзадач
- Особенно эффективна при внешних вызовах (API, I/O)
- В LangChain используется `RunnableParallel`
- В Google ADK — мультиагентная делегация
- Снижает суммарную задержку и повышает отзывчивость
- Требует асинхронной архитектуры

## Ссылки

1. [LCEL](https://python.langchain.com/docs/concepts/lcel/)
2. [Google ADK Multi-agents](https://google.github.io/adk-docs/agents/multi-agents/)
3. [Python asyncio](https://docs.python.org/3/library/asyncio.html)
