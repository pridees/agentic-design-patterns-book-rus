# Глава 1: Цепочки промптов

## Обзор паттерна «Цепочки промптов»

Цепочки промптов (часто также называемые паттерном «конвейер», Pipeline) — это мощная парадигма для решения сложных задач с использованием больших языковых моделей (LLM). Вместо того чтобы ожидать от LLM решения сложной проблемы за один монолитный шаг, метод цепочек промптов предлагает стратегию «разделяй и властвуй». Суть заключается в декомпозиции исходной, пугающей задачи на последовательность более мелких и управляемых подзадач. Каждая подзадача решается отдельным, специально спроектированным промптом, а результат одного шага целенаправленно подается на вход следующему шагу в цепочке.

Такая последовательная обработка привносит в взаимодействие с LLM модульность и ясность. Декомпозируя сложную задачу, проще понять и отладить каждый отдельный шаг, что делает весь процесс более надежным и интерпретируемым. Каждый шаг цепочки можно тщательно сконструировать и оптимизировать под конкретный аспект общей проблемы, получая более точные и сфокусированные результаты.

Критически важно, что выход одного шага становится входом для следующего. Эта передача информации образует «цепь зависимостей», благодаря которой контекст и результаты предыдущих операций направляют последующую обработку. Модель опирается на уже выполненную работу, уточняет понимание и постепенно приближается к искомому решению.

Кроме того, цепочки промптов — это не только про разбиение задач; они также позволяют интегрировать внешние знания и инструменты. На каждом шаге LLM может взаимодействовать с внешними системами, API или базами данных, пополняя свои знания и возможности за пределами собственных обучающих данных. Это радикально расширяет потенциал LLM, превращая их не в изолированные модели, а в составные элементы более широких интеллектуальных систем.

Значимость цепочек промптов выходит за рамки «просто решить задачу». Это фундаментальная техника для построения сложных ИИ-агентов. Такие агенты используют цепочки промптов, чтобы автономно планировать, рассуждать и действовать в динамичных средах. При продуманной структуре последовательности промптов агент способен выполнять задачи, требующие многошагового рассуждения, планирования и принятия решений. Подобные сценарии работы приближают ход решения к человеческому, что обеспечивает более естественные и эффективные взаимодействия со сложными доменами и системами.

**Ограничения одиночных промптов.** Для многогранных задач один сложный промпт для LLM часто неэффективен: модель может «спотыкаться» о многочисленные ограничения и инструкции. Это ведет к пропуску инструкций (instruction neglect), дрейфу контекста (contextual drift), накоплению ошибок (error propagation), ситуациям с недостатком контекста при длинных промптах, а также к галлюцинациям — росту вероятности неверной информации из‑за повышенной когнитивной нагрузки. Например, запрос «проанализировать отчет маркетингового исследования, суммировать выводы, выделить тренды с данными и составить письмо» рискует провалиться: модель может неплохо суммировать, но не извлечь корректные данные или плохо написать письмо.

**Повышение надежности благодаря последовательной декомпозиции.** Цепочки промптов устраняют эти проблемы за счет разбиения сложной задачи на сфокусированный последовательный рабочий процесс, существенно повышая управляемость и надежность. Для приведенного выше примера конвейер может выглядеть так:

1. Исходный промпт (суммаризация): «Суммируй ключевые выводы следующего отчета о маркетинговом исследовании: [text]». Узкий фокус повышает точность первого шага.
2. Второй промпт (выделение трендов): «Используя суммаризацию, выдели три ведущих тренда и извлеки конкретные данные, подтверждающие каждый: [output from step 1]». Промпт становится более ограниченным и опирается на проверенный выход.
3. Третий промпт (составление письма): «Составь краткое письмо для маркетинговой команды, описав выделенные тренды и подтверждающие данные: [output from step 2]».

Такая декомпозиция дает более тонкий контроль над процессом. Каждый шаг проще и менее двусмысленен, снижает когнитивную нагрузку на модель и повышает точность итогового результата. Модульность схожа с вычислительным конвейером, где каждая функция выполняет конкретную операцию и передает результат далее. Чтобы обеспечить точность ответа на каждом шаге, модели можно задавать роль. В нашем примере первый промпт — «Аналитик рынка», второй — «Аналитик торговли», третий — «Эксперт по документации» и т. д.

**Роль структурированного выхода.** Надежность цепочки напрямую зависит от качества передаваемых между шагами данных. Если выход одного промпта неоднозначен или слабо структурирован, следующий шаг может «сломаться» на некачественном входе. Поэтому важно задавать строгий формат, например JSON или XML.

Пример структурированного выхода для шага с трендами:

```json
{
  "trends": [
    {
      "trend_name": "AI-Powered Personalization",
      "supporting_data": "73% of consumers prefer to do business with brands that use personal information to make their shopping experiences more relevant."
    },
    {
      "trend_name": "Sustainable and Ethical Brands",
      "supporting_data": "Sales of products with ESG-related claims grew 28% over the last five years, compared to 20% for products without."
    }
  ]
}
```

Такой формат делает данные машиночитаемыми, что позволяет однозначно парсить и подавать их на следующий шаг без интерпретационных ошибок. Эта практика минимизирует проблемы, связанные с интерпретацией естественного языка, и является ключевым компонентом надежных многошаговых систем на базе LLM.

## Практические применения и сценарии использования

Цепочки промптов — универсальный паттерн для широкого спектра задач при разработке агентных систем. Его основная полезность — разбиение сложной проблемы на последовательные управляемые шаги. Ниже несколько типичных сценариев:

**1. Контур обработки информации.** Многие задачи требуют последовательных трансформаций сырых данных. Например, суммаризация документа, извлечение сущностей, затем использование этих сущностей для запроса в базу и генерации отчета. Цепочка промптов может выглядеть так:

- Промпт 1: Извлечь текст из указанного URL или документа.
- Промпт 2: Суммировать очищенный текст.
- Промпт 3: Извлечь сущности (имена, даты, локации) из суммаризации или исходного текста.
- Промпт 4: Использовать сущности для поиска во внутренней базе знаний.
- Промпт 5: Сформировать итоговый отчет с учетом суммаризации, сущностей и результатов поиска.

Это применяется в автоматическом анализе контента, в ИИ‑ассистентах для исследований и при генерации сложных отчетов.

**2. Ответы на сложные вопросы.** Задачи, требующие многократного рассуждения или поиска информации. Пример: «Каковы основные причины краха фондового рынка в 1929 году и как отреагировало правительство?»

- Промпт 1: Выделить подзадачи вопроса (причины краха, реакция правительства).
- Промпт 2: Исследовать причины краха 1929 года.
- Промпт 3: Исследовать реакцию правительства на крах 1929 года.
- Промпт 4: Синтезировать информацию из шагов 2 и 3 в единый ответ.

Такой подход — основа систем многошагового вывода и синтеза информации, когда ответ не извлекается из одной точки данных, а требует цепочки логических шагов и интеграции разнотипных источников.

Например, автоматический исследователь, генерирующий комплексный обзор темы, использует гибридный рабочий процесс. Сначала система извлекает множество релевантных статей. Далее параллельно обрабатывает каждую статью для извлечения ключевой информации — независимые подзадачи, отлично подходящие для параллелизма. После завершения извлечения начинается последовательный этап: колlation данных, их синтез в черновик и финальный обзор/редактура. Эти шаги зависят друг от друга: данные → синтез → редактура. Здесь и применяется цепочка промптов.

**3. Извлечение и трансформация данных.** Преобразование неструктурированного текста в структурированный формат обычно достигается итеративно, с последовательными улучшениями точности и полноты.

- Промпт 1: Попытаться извлечь заданные поля (например, имя, адрес, сумма) из счета/накладной.
- Обработка: Проверить полноту и корректность форматов.
- Промпт 2 (условный): Если поля пропущены/некорректны, сформировать промпт на доизвлечение, используя контекст неудачной попытки.
- Обработка: Повторная валидация. При необходимости — повтор.
- Выход: Валидированные структурированные данные.

Этот подход особенно актуален для извлечения и анализа данных из неструктурированных источников (формы, счета, письма). Например, сложные задачи OCR — обработка PDF‑форм: этап 1 — извлечение текста LLM; этап 2 — нормализация (конвертация «одна тысяча пятьдесят» в 1050); этап 3 — делегирование точных вычислений внешнему калькулятору. LLM формулирует задачу, передает нормализованные числа инструменту и затем включает результат. Такая цепочка — извлечение текста → нормализация → внешний инструмент — обычно надежнее одного запроса к LLM.

**4. Генерация контента.** Создание сложного контента — процедурная задача, обычно разделяемая на этапы: идеи, структура, черновик, ревизия.

- Промпт 1: Сгенерировать 5 идей по интересу пользователя.
- Обработка: Пользователь выбирает идею или система подбирает лучшую.
- Промпт 2: Сгенерировать детальный план по выбранной теме.
- Промпт 3: Написать раздел по первому пункту плана.
- Промпт 4: Написать раздел по второму пункту, учитывая предыдущий; продолжать по пунктам.
- Промпт 5: Отрецензировать и отредактировать целый текст на связность, тон и грамматику.

Это применяется для NLG‑задач: творческие тексты, техдокументация и другие форматы структурированного контента.

**5. Разговорные агенты с состоянием.** Хотя полноценные архитектуры состояния сложнее простой линейной сцепки, цепочки промптов дают базовый механизм поддержания контекста. Каждый ход — новый промпт, включающий информацию или выделенные сущности из предыдущих ходов.

- Промпт 1: Обработать высказывание пользователя 1, выделить интент и сущности.
- Обработка: Обновить состояние диалога.
- Промпт 2: С учетом состояния — сгенерировать ответ и/или запросить недостающую информацию.
- Повтор: Каждый новый ход формирует цепочку, использующую накапливаемый контекст.

Это фундамент для диалоговых агентов, поддерживающих связность и когерентность в длительных беседах.

**6. Генерация и улучшение кода.** Создание рабочего кода — многошаговый процесс, где задача декомпозируется на последовательность логических операций.

- Промпт 1: Понять запрос к функции; сгенерировать псевдокод/набросок.
- Промпт 2: Написать первичный код по наброску.
- Промпт 3: Выявить ошибки/зоны улучшения (статический анализ или LLM).
- Промпт 4: Переписать/улучшить код.
- Промпт 5: Добавить документацию или тесты.

Такой модульный подход снижает сложность каждого шага для LLM и позволяет вставлять детерминированную логику между вызовами модели: промежуточная обработка, валидация, ветвления. Таким образом, одна «многоэтапная просьба» превращается в контролируемую последовательность операций в рамках исполняющего каркаса.

**7. Мультимодальные и многошаговые рассуждения.** Анализ данных разных модальностей требует разбивки на мелкие, промпт‑ориентированные задачи. Например, интерпретация изображения с встроенным текстом, подписями с выделенными сегментами и таблицей, объясняющей каждую подпись, — типичный случай.

- Промпт 1: Извлечь и понять текст из изображения пользователя.
- Промпт 2: Соотнести извлеченный текст с его подписями/метками.
- Промпт 3: Интерпретировать полученную информацию, используя таблицу, чтобы получить требуемый результат.

## Практический пример кода

Реализация цепочек промптов может варьироваться от прямых последовательных вызовов в скрипте до использования специализированных фреймворков для управления потоком, состоянием и интеграцией компонентов. LangChain, LangGraph, Crew AI и Google Agent Development Kit (ADK) предлагают структурированную среду для построения и исполнения многошаговых процессов, что особенно удобно для сложных архитектур.

Для демонстрации подойдут LangChain и LangGraph: их API ориентированы на композицию цепочек и графов операций. LangChain предоставляет базовые абстракции для линейных последовательностей, а LangGraph расширяет их до состояния и циклов, необходимых для более «агентных» поведений. Ниже — пример базовой линейной последовательности.

Ниже приведена двухшаговая цепочка, работающая как конвейер обработки текста. На первом шаге из неструктурированного текста извлекается определенная информация. На втором шаге этот выход преобразуется в структурированные данные.

Чтобы воспроизвести пример, установите библиотеки:

```bash
pip install langchain langchain-community langchain-openai langgraph
```

Учтите: `langchain-openai` можно заменить пакетом нужного провайдера модели. Далее настройте переменные окружения с API‑ключами выбранного провайдера (OpenAI, Google Gemini, Anthropic и др.).

```python
import os from langchain_openai
import ChatOpenAI from langchain_core.prompts
import ChatPromptTemplate from langchain_core.output_parsers
import StrOutputParser

# For better security, load environment variables from a .env file
# from dotenv import load_dotenv
# load_dotenv()
# Make sure your OPENAI_API_KEY is set in the .env file
# Initialize the Language Model (using ChatOpenAI is recommended)
llm = ChatOpenAI(temperature=0)
# --- Prompt 1: Extract Information ---
prompt_extract = ChatPromptTemplate.from_template(
  "Extract the technical specifications from the following text:\n\n{text_input}"
)

# --- Prompt 2: Transform to JSON ---

prompt_transform = ChatPromptTemplate.from_template(
  "Transform the following specifications into a JSON object with 'cpu', 'memory', and 'storage' as keys:\n\n{specifications}"
)

# --- Build the Chain using LCEL ---
# The StrOutputParser() converts the LLM's message output to a simple string.

extraction_chain = prompt_extract | llm | StrOutputParser()
# The full chain passes the output of the extraction chain into the 'specifications'
# variable for the transformation prompt.

full_chain = (
  {"specifications": extraction_chain}
    | prompt_transform
    | llm
    | StrOutputParser()
  )
  # --- Run the Chain --- input_text = "The new laptop model features a 3.5 GHz octa-core processor, 16GB of RAM, and a 1TB NVMe SSD."
  # Execute the chain with the input text dictionary.

  final_result = full_chain.invoke({"text_input": input_text}) print("\n--- Final JSON Output ---") print(final_result)
```

Этот код на Python показывает, как использовать LangChain для обработки текста. Здесь применены два промпта: первый извлекает технические характеристики из строки, второй — форматирует их в JSON‑объект. Взаимодействие с моделью выполняет `ChatOpenAI`, а `StrOutputParser` приводит ответ к строке. LCEL (LangChain Expression Language) облегчает композицию промптов и модели. Цепочка `extraction_chain` извлекает характеристики; затем `full_chain` передает их в промпт трансформации. На вход подается описание ноутбука, на выходе — JSON‑строка со структурированными характеристиками.

# Инжиниринг контекста и инжиниринг промптов

Инжиниринг контекста (см. рис. 1) — это систематическая дисциплина проектирования, построения и доставки полной информационной среды модели до начала генерации токенов. Этот подход утверждает, что качество ответов зависит не столько от архитектуры модели, сколько от богатства предоставленного контекста.

![][image2]

Рис. 1. Инжиниринг контекста — дисциплина построения богатой, целостной информационной среды для ИИ; качество этой среды — ключевой фактор продвинутой агентной производительности.

Это — развитие классического «инжиниринга промптов», сфокусированного на формулировке конкретного запроса. Инжиниринг контекста расширяет рамки: включает системный промпт (базовые инструкции: например, «вы — технический писатель; тон — официальный и точный»), внешние данные (извлеченные документы, результаты инструментов/интеграций), а также неявные данные (личность пользователя, история взаимодействий, состояние окружения). Принцип: даже продвинутые модели дают посредственные результаты при узком и плохо сконструированном представлении среды.

Задача переосмысляется: не просто ответить, а сформировать операционную картину для агента. Например, агент сначала интегрирует доступность из календаря (выход инструмента), характер отношений с адресатом письма (неявные данные) и заметки прошлых встреч (retrieval), а затем формирует релевантный, персонализированный, практически полезный ответ. «Инжиниринг» означает построение надежных конвейеров загрузки и трансформации данных в рантайме и создание контуров обратной связи для улучшения качества контекста.

Для внедрения применяются системы авто‑настройки на масштабе. Например, Google Vertex AI Prompt Optimizer может улучшать качество, автоматически оценивая ответы на тестовых наборах и метриках. Подход эффективен для адаптации промптов и системных инструкций под разные модели без ручной переработки: оптимизатору передают примеры, системные инструкции и шаблон; он итеративно улучшает контекст.

Это и отличает «простой инструмент» от «контекстно‑осведомленной системы»: контекст становится первоклассной сущностью — что знает агент, когда знает и как использует. В итоге модель лучше понимает намерения, историю и среду пользователя. Инжиниринг контекста — ключевой метод перехода от статичных чат‑ботов к способным, ситуационно‑осведомленным системам.

## Коротко

**Что:** Сложные задачи часто перегружают LLM, если решаются одним промптом. Растет когнитивная нагрузка, повышается риск пропуска инструкций, потери контекста и генерации неверной информации. Один монолитный промпт плохо справляется с множественными ограничениями и последовательным рассуждением — итог ненадежен и неточен.

**Почему:** Цепочки промптов стандартизируют решение — разбивают сложную проблему на последовательность меньших, взаимосвязанных подзадач. Каждый шаг — сфокусированный промпт, который повышает надежность и управляемость. Выход одного шага — вход следующего, формируя логический рабочий процесс, постепенно приводящий к итоговому решению. Модульность упрощает отладку и позволяет интегрировать внешние инструменты и структурированные форматы между шагами. Этот паттерн — основа для сложных агентных систем, способных планировать, рассуждать и исполнять многошаговые процессы.

**Практическое правило:** Применяйте, когда задача слишком сложна для одного промпта, включает несколько разнородных стадий, требует интеграции с внешними инструментами между шагами или когда вы строите агентные системы с многошаговым рассуждением и состоянием.

**Визуальное резюме**

![][image1]

Рис. 2. Паттерн «Цепочки промптов»: агенты получают серию промптов от пользователя, а выход каждого шага служит входом для следующего в цепочке.

## Ключевые выводы

Ниже — основные тезисы:

- Цепочки промптов разбивают сложные задачи на последовательность меньших, сфокусированных шагов (иногда — «конвейер»).
- Каждый шаг — вызов LLM или логика обработки, использующая выход предыдущего шага как вход.
- Паттерн повышает надежность и управляемость сложных взаимодействий с LLM.
- Фреймворки LangChain/LangGraph и Google ADK предоставляют удобные средства для определения, управления и исполнения таких многошаговых последовательностей.

## Заключение

Декомпозируя сложные проблемы на цепочку более простых подзадач, цепочки промптов дают надежный каркас для управления LLM. Подход «разделяй и властвуй» значительно повышает качество и контролируемость результата, фокусируя модель на одном конкретном действии за раз. Как фундаментальный паттерн, он позволяет строить сложных ИИ‑агентов с многошаговым рассуждением, интеграцией инструментов и управлением состоянием. Освоение цепочек промптов — ключ к созданию надежных контекстно‑осведомленных систем, способных исполнять сложные рабочие процессы далеко за пределами возможностей одного промпта.

## Ссылки

1. [Документация LangChain по LCEL](https://python.langchain.com/v0.2/docs/core_modules/expression_language/)
2. [Документация LangGraph](https://langchain-ai.github.io/langgraph/)
3. [Prompt Engineering Guide — Chaining Prompts](https://www.promptingguide.ai/techniques/chaining)
4. [OpenAI API — General Prompting Concepts](https://platform.openai.com/docs/guides/gpt/prompting)
5. [Документация Crew AI (Tasks and Processes)](https://docs.crewai.com/)
6. [Google AI for Developers (Prompting Guides)](https://cloud.google.com/discover/what-is-prompt-engineering?hl=en)
7. [Vertex Prompt Optimizer](https://cloud.google.com/vertex-ai/generative-ai/docs/learn/prompts/prompt-optimizer)

[image1]: ../Assets/chapter-1-image1.png
[image2]: ../Assets/chapter-1-image2.png

---

## Навигация

**Назад:** [Что делает AI систему агентом?](../2.%20Что%20делает%20AI%20систему%20агентом.md)  
**Вперед:** [Глава 2. Маршрутизация](Глава%202.%20Маршрутизация.md)
