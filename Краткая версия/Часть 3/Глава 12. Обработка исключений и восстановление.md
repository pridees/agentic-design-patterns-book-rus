# Глава 12: Обработка исключений и восстановление

## Обзор паттерна

Обработка исключений и восстановление — паттерн для создания устойчивых агентов, способных справляться с непредвиденными ситуациями, ошибками и сбоями. Обеспечивает непрерывную функциональность при столкновении с трудностями.

**Ключевые компоненты:**
- Обнаружение ошибок
- Логирование и диагностика
- Стратегии восстановления
- Fallback-механизмы

## Стратегии обработки ошибок

**1. Обнаружение:**
- Невалидные выходные данные инструментов
- Ошибки API (404, 500)
- Таймауты и задержки
- Бессвязные ответы
- Мониторинг другими агентами

**2. Восстановление:**
- **Повторные попытки:** Retry с экспоненциальной задержкой
- **Fallback:** Альтернативные методы/инструменты
- **Плавная деградация:** Частичная функциональность
- **Откат состояния:** Возврат к стабильной точке
- **Эскалация:** Передача человеку

## Практические применения

- **Чат-боты:** Обработка ошибок БД, сетевых сбоев
- **Торговые боты:** Управление финансовыми API-ошибками
- **Умный дом:** Восстановление после сбоев устройств
- **Исследовательские агенты:** Fallback при недоступности источников

## Практический пример кода

```python
from langchain.agents import Tool
import time

class ResilientAgent:
    def __init__(self, max_retries=3):
        self.max_retries = max_retries
    
    def execute_with_retry(self, func, *args, **kwargs):
        """Выполнение с повторными попытками"""
        for attempt in range(self.max_retries):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                print(f"Попытка {attempt + 1} failed: {e}")
                if attempt < self.max_retries - 1:
                    time.sleep(2 ** attempt)  # Экспоненциальная задержка
                else:
                    return self.fallback_action(e)
    
    def fallback_action(self, error):
        """Альтернативное действие при сбое"""
        return f"Fallback: не удалось выполнить, причина: {error}"
    
    def execute_with_degradation(self, primary_func, fallback_func):
        """Плавная деградация"""
        try:
            return primary_func()
        except Exception as e:
            print(f"Primary failed: {e}, using fallback")
            return fallback_func()

# Использование
agent = ResilientAgent()

def risky_operation():
    # Симуляция операции с возможным сбоем
    import random
    if random.random() < 0.3:
        raise Exception("API unavailable")
    return "Success"

result = agent.execute_with_retry(risky_operation)
print(result)
```

## Связь с рефлексией

Может использоваться совместно с рефлексией (Глава 4): при сбое рефлексивный процесс анализирует неудачу и повторяет с уточнённым подходом.

## Ключевые выводы

- Обработка исключений критична для надёжных агентов
- Включает обнаружение, логирование, восстановление
- Retry с экспоненциальной задержкой для временных сбоев
- Fallback-механизмы для альтернативных путей
- Плавная деградация для частичной функциональности
- Эскалация при критических ситуациях
- Повышает устойчивость в непредсказуемых средах
