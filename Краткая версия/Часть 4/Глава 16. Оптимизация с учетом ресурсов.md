# Глава 16: Оптимизация с учётом ресурсов

## Обзор паттерна

Resource-Aware Optimization — динамическое управление вычислительными, временными и финансовыми ресурсами при выполнении задач. Агенты принимают решения о выделении ресурсов для оптимизации эффективности и достижения целей в рамках бюджетов.

**Ключевые решения:**
- Выбор между точной, но дорогой моделью и быстрой, доступной
- Выделение дополнительных ресурсов для детального анализа
- Использование fallback при недоступности предпочтительной модели

## Стратегии оптимизации

**1. Выбор модели:**
- Высококачественные (GPT-4, Gemini Pro) для критических задач
- Эффективные (GPT-4o-mini, Gemini Flash) для простых запросов
- Локальные модели для конфиденциальных данных

**2. Fallback механизмы:**
- Автоматическое переключение при недоступности
- Каскадный fallback (primary → secondary → tertiary)
- Изящная деградация функциональности

**3. Бюджетирование:**
- Токен-лимиты
- Временные ограничения
- Стоимостные пороги

## Практические применения

- **Финансовый анализ:** Быстрая модель для предварительных отчётов, точная для критических прогнозов
- **Контент-генерация:** Эффективная модель для черновиков, премиум для финального контента
- **Поддержка клиентов:** Быстрая модель для FAQ, продвинутая для сложных вопросов
- **Обработка данных:** Распределение задач по мощности и срочности

## Практический пример кода

```python
from langchain_openai import ChatOpenAI

class ResourceAwareAgent:
    def __init__(self):
        self.models = {
            'premium': ChatOpenAI(model="gpt-4", temperature=0),
            'standard': ChatOpenAI(model="gpt-4o-mini", temperature=0),
            'fast': ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
        }
        self.budget_used = 0
        self.budget_limit = 100  # токенов
    
    def select_model(self, task_complexity, urgency):
        """Выбор модели на основе сложности и срочности"""
        if self.budget_used > self.budget_limit * 0.9:
            return self.models['fast']
        
        if task_complexity == 'high' and urgency == 'critical':
            return self.models['premium']
        elif task_complexity == 'medium':
            return self.models['standard']
        else:
            return self.models['fast']
    
    def execute_with_fallback(self, query, task_complexity='medium', urgency='normal'):
        """Выполнение с fallback"""
        models_priority = ['premium', 'standard', 'fast']
        
        selected = self.select_model(task_complexity, urgency)
        
        for model_name in models_priority:
            try:
                model = self.models[model_name]
                response = model.invoke(query)
                self.budget_used += len(response.content.split())
                return response.content
            except Exception as e:
                print(f"Модель {model_name} недоступна: {e}")
                continue
        
        return "Все модели недоступны"

# Использование
agent = ResourceAwareAgent()

# Критическая задача
result = agent.execute_with_fallback(
    "Проанализируй финансовый риск инвестиции",
    task_complexity='high',
    urgency='critical'
)
```

## Метрики оптимизации

1. **Стоимость:** Цена за токен/запрос
2. **Латентность:** Время ответа
3. **Качество:** Точность результата
4. **Доступность:** Uptime модели

## Инструменты

**OpenRouter:**
- Агрегатор множества моделей
- Автоматический fallback
- Прозрачное ценообразование

**Google Gemini:**
- Flash 2.5 для эффективности
- Pro для качества
- Оптимальное соотношение цена/качество

## Ключевые выводы

- Оптимизация ресурсов балансирует качество, скорость и стоимость
- Динамический выбор модели на основе требований задачи
- Fallback обеспечивает надёжность при сбоях
- Бюджетирование предотвращает перерасход
- Критично для production-систем
- OpenRouter и Gemini упрощают реализацию
- Мониторинг использования для оптимизации
