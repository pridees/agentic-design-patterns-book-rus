# Приложение C - Краткий обзор агентных фреймворков

## LangChain

LangChain — это фреймворк для разработки приложений на основе LLM. Его основная сила заключается в LangChain Expression Language (LCEL), который позволяет "соединять" компоненты в цепочку. Это создает четкую, линейную последовательность, где выход одного шага становится входом для следующего. Он построен для рабочих процессов, которые являются направленными ациклическими графами (DAG), что означает, что процесс течет в одном направлении без циклов.

Используйте его для:

- **Простой RAG**: Получить документ, создать промпт, получить ответ от LLM.
- **Суммаризация**: Взять пользовательский текст, передать его в промпт для суммаризации и вернуть результат.
- **Извлечение**: Извлечь структурированные данные (например, JSON) из блока текста.

**Python**

```python
# Простая LCEL цепочка концептуально
# (Это не исполняемый код, просто иллюстрирует поток)
chain = prompt | model | output_parse
```

### LangGraph

LangGraph — это библиотека, построенная поверх LangChain для обработки более продвинутых агентных систем. Она позволяет определять ваш рабочий процесс как граф с узлами (функциями или LCEL цепочками) и ребрами (условной логикой). Ее основное преимущество — способность создавать циклы, позволяя приложению зацикливаться, повторять попытки или вызывать инструменты в гибком порядке до завершения задачи. Она явно управляет состоянием приложения, которое передается между узлами и обновляется на протяжении всего процесса.

Используйте его для:

- **Мульти-агентные системы**: Агент-супервизор направляет задачи специализированным рабочим агентам, потенциально зацикливаясь до достижения цели.
- **Планирующие и исполняющие агенты**: Агент создает план, выполняет шаг, а затем возвращается к обновлению плана на основе результата.
- **Человек в контуре**: Граф может ждать человеческого ввода перед решением, к какому узлу перейти дальше.

| Функция                | LangChain                                 | LangGraph                                 |
| ---------------------- | ----------------------------------------- | ----------------------------------------- |
| Основная абстракция    | Цепочка (используя LCEL)                  | Граф узлов                                |
| Тип рабочего процесса  | Линейный (направленный ациклический граф) | Циклический (графы с циклами)             |
| Управление состоянием  | Обычно без состояния на запуск            | Явный и постоянный объект состояния       |
| Основное использование | Простые, предсказуемые последовательности | Сложные, динамичные, состоятельные агенты |

### Какой выбрать?

- **Выберите LangChain**, когда ваше приложение имеет четкий, предсказуемый и линейный поток шагов. Если вы можете определить процесс от A к B к C без необходимости зацикливания, LangChain с LCEL — идеальный инструмент.

- **Выберите LangGraph**, когда вам нужно, чтобы ваше приложение рассуждало, планировало или работало в цикле. Если ваш агент должен использовать инструменты, размышлять о результатах и потенциально пробовать снова с другим подходом, вам нужна циклическая и состоятельная природа LangGraph.

**Python**

```python
# Состояние графа
class State(TypedDict):
    topic: str
    joke: str
    story: str
    poem: str
    combined_output: str

# Узлы
def call_llm_1(state: State):
    """Первый вызов LLM для генерации начальной шутки"""

    msg = llm.invoke(f"Write a joke about {state['topic']}")
    return {"joke": msg.content}

def call_llm_2(state: State):
    """Второй вызов LLM для генерации истории"""

    msg = llm.invoke(f"Write a story about {state['topic']}")
    return {"story": msg.content}

def call_llm_3(state: State):
    """Третий вызов LLM для генерации стихотворения"""

    msg = llm.invoke(f"Write a poem about {state['topic']}")
    return {"poem": msg.content}

def aggregator(state: State):
    """Объединить шутку и историю в единый вывод"""

    combined = f"Here's a story, joke, and poem about {state['topic']}!\n\n"
    combined += f"STORY:\n{state['story']}\n\n"
    combined += f"JOKE:\n{state['joke']}\n\n"
    combined += f"POEM:\n{state['poem']}"
    return {"combined_output": combined}

# Построить рабочий процесс
parallel_builder = StateGraph(State)

# Добавить узлы
parallel_builder.add_node("call_llm_1", call_llm_1)
parallel_builder.add_node("call_llm_2", call_llm_2)
parallel_builder.add_node("call_llm_3", call_llm_3)
parallel_builder.add_node("aggregator", aggregator)

# Добавить ребра для соединения узлов
parallel_builder.add_edge(START, "call_llm_1")
parallel_builder.add_edge(START, "call_llm_2")
parallel_builder.add_edge(START, "call_llm_3")
parallel_builder.add_edge("call_llm_1", "aggregator")
parallel_builder.add_edge("call_llm_2", "aggregator")
parallel_builder.add_edge("call_llm_3", "aggregator")
parallel_builder.add_edge("aggregator", END)
parallel_workflow = parallel_builder.compile()

# Показать рабочий процесс
display(Image(parallel_workflow.get_graph().draw_mermaid_png()))

# Вызвать
state = parallel_workflow.invoke({"topic": "cats"})
print(state["combined_output"])
```

Этот код определяет и запускает рабочий процесс LangGraph, который работает параллельно. Его основная цель — одновременно генерировать шутку, историю и стихотворение на заданную тему, а затем объединять их в единый форматированный текстовый вывод.

## Google's ADK

Google's Agent Development Kit, или ADK, предоставляет высокоуровневый, структурированный фреймворк для создания и развертывания приложений, состоящих из множества взаимодействующих AI агентов. Он контрастирует с LangChain и LangGraph, предлагая более предвзятый и производственно-ориентированный подход к оркестрации сотрудничества агентов, а не предоставляя фундаментальные строительные блоки для внутренней логики агента.

LangChain работает на самом фундаментальном уровне, предлагая компоненты и стандартизированные интерфейсы для создания последовательностей операций, таких как вызов модели и парсинг ее вывода. LangGraph расширяет это, вводя более гибкий и мощный контроль потока; он рассматривает рабочий процесс агента как состоятельный граф. Используя LangGraph, разработчик явно определяет узлы, которые являются функциями или инструментами, и ребра, которые диктуют путь выполнения. Эта структура графа позволяет сложному, циклическому рассуждению, где система может зацикливаться, повторять задачи и принимать решения на основе явно управляемого объекта состояния, который передается между узлами. Это дает разработчику детальный контроль над мыслительным процессом одного агента или возможность построить мульти-агентную систему с нуля.

**Google's ADK абстрагирует большую часть этой низкоуровневой конструкции графа. Вместо того чтобы просить разработчика определить каждый узел и ребро, он предоставляет предварительно построенные архитектурные паттерны для мульти-агентного взаимодействия. Например, ADK имеет встроенные типы агентов, такие как `SequentialAgent` или `ParallelAgent`, которые автоматически управляют потоком контроля между различными агентами. Он архитектурирован вокруг концепции "команды" агентов, часто с первичным агентом, делегирующим задачи специализированным под-агентам. Управление состоянием и сессией обрабатывается более неявно фреймворком, предоставляя более сплоченный, но менее детальный подход, чем явная передача состояния LangGraph. Поэтому, пока LangGraph дает вам детальные инструменты для проектирования сложной проводки одного робота или команды, Google's ADK дает вам заводскую сборочную линию, предназначенную для создания и управления флотом роботов, которые уже знают, как работать вместе.**

**Python**

```python
from google.adk.agents import LlmAgent
from google.adk.tools import google_Search

dice_agent = LlmAgent(
    model="gemini-2.0-flash-exp",
    name="question_answer_agent",
    description="A helpful assistant agent that can answer questions.",
    instruction="""Respond to the query using google search""",
    tools=[google_search],
)
```

Этот код создает **агента с поисковым усилением**. Когда этот агент получает вопрос, он не будет просто полагаться на свои предварительные знания. Вместо этого, следуя своим инструкциям, он будет использовать инструмент Google Search для поиска релевантной, актуальной информации из интернета, а затем использовать эту информацию для построения своего ответа.

## Crew.AI

CrewAI предлагает фреймворк оркестрации для построения мульти-агентных систем, фокусируясь на совместных ролях и структурированных процессах. Он работает на более высоком уровне абстракции, чем фундаментальные инструментарии, предоставляя концептуальную модель, которая отражает человеческую команду. Вместо определения детального потока логики как графа, разработчик определяет акторов и их назначения, а CrewAI управляет их взаимодействием.

Основными компонентами этого фреймворка являются Агенты, Задачи и Команда. Агент определяется не только своей функцией, но и персоной, включая конкретную роль, цель и предысторию, которая направляет его поведение и стиль общения. Задача — это дискретная единица работы с четким описанием и ожидаемым выводом, назначенная конкретному Агенту. Команда — это сплоченная единица, которая содержит Агентов и список Задач, и она выполняет предопределенный Процесс. Этот процесс диктует рабочий процесс, который обычно либо последовательный, где вывод одной задачи становится входом для следующей в очереди, либо иерархический, где агент-менеджер делегирует задачи и координирует рабочий процесс среди других агентов.

При сравнении с другими фреймворками, CrewAI занимает отличную позицию. Он отходит от низкоуровневого, явного управления состоянием и контроля потока LangGraph, где разработчик соединяет каждый узел и условное ребро. Вместо построения конечного автомата, разработчик проектирует устав команды. В то время как Google's ADK предоставляет комплексную, производственно-ориентированную платформу для всего жизненного цикла агента, CrewAI концентрируется конкретно на логике сотрудничества агентов и для симуляции команды специалистов.

**Python**

```python
@crew
def crew(self) -> Crew:
    """Creates the research crew"""
    return Crew(
        agents=self.agents,
        tasks=self.tasks,
        process=Process.sequential,
        verbose=True,
    )
```

Этот код настраивает последовательный рабочий процесс для команды AI агентов, где они решают список задач в определенном порядке, с включенным детальным логированием для мониторинга их прогресса.

## Другие фреймворки разработки агентов

**Microsoft AutoGen**: AutoGen — это фреймворк, сосредоточенный на оркестрации множественных агентов, которые решают задачи через разговор. Его архитектура позволяет агентам с различными возможностями взаимодействовать, позволяя сложную декомпозицию проблем и совместное разрешение. Основное преимущество AutoGen — его гибкий, разговорно-ориентированный подход, который поддерживает динамичные и сложные мульти-агентные взаимодействия. Однако эта разговорная парадигма может привести к менее предсказуемым путям выполнения и может потребовать сложного промпт-инжиниринга для обеспечения эффективной сходимости задач.

**LlamaIndex**: LlamaIndex — это фундаментально фреймворк данных, предназначенный для соединения больших языковых моделей с внешними и приватными источниками данных. Он преуспевает в создании сложных пайплайнов приема и извлечения данных, которые необходимы для построения знающих агентов, которые могут выполнять RAG. В то время как его возможности индексации и запросов данных исключительно мощны для создания контекстно-осведомленных агентов, его нативные инструменты для сложного агентного контроля потока и мульти-агентной оркестрации менее развиты по сравнению с агент-ориентированными фреймворками. LlamaIndex оптимален, когда основная техническая задача — извлечение и синтез данных.

**Haystack**: Haystack — это открытый фреймворк, спроектированный для построения масштабируемых и готовых к производству поисковых систем, работающих на языковых моделях. Его архитектура состоит из модульных, взаимозаменяемых узлов, которые формируют пайплайны для извлечения документов, ответов на вопросы и суммаризации. Основная сила Haystack — его фокус на производительности и масштабируемости для крупномасштабных задач извлечения информации, что делает его подходящим для корпоративных приложений. Потенциальный компромисс заключается в том, что его дизайн, оптимизированный для поисковых пайплайнов, может быть более жестким для реализации высокодинамичного и творческого агентного поведения.

**MetaGPT**: MetaGPT реализует мульти-агентную систему, назначая роли и задачи на основе предопределенного набора стандартных операционных процедур (SOP). Этот фреймворк структурирует сотрудничество агентов, чтобы имитировать компанию разработки программного обеспечения, с агентами, принимающими роли, такие как менеджеры продуктов или инженеры для выполнения сложных задач. Этот подход, управляемый SOP, приводит к высоко структурированным и связным выводам, что является значительным преимуществом для специализированных доменов, таких как генерация кода. Основное ограничение фреймворка — его высокая степень специализации, что делает его менее адаптируемым для общих агентных задач вне его основного дизайна.

**SuperAGI**: SuperAGI — это открытый фреймворк, предназначенный для предоставления полной системы управления жизненным циклом для автономных агентов. Он включает функции для обеспечения агентов, мониторинга и графического интерфейса, стремясь повысить надежность выполнения агентов. Ключевое преимущество — его фокус на готовности к производству, со встроенными механизмами для обработки общих режимов отказа, таких как зацикливание, и для предоставления наблюдаемости производительности агентов. Потенциальный недостаток заключается в том, что его комплексный платформенный подход может ввести больше сложности и накладных расходов, чем более легкий, библиотечный фреймворк.

**Semantic Kernel**: Разработанный Microsoft, Semantic Kernel — это SDK, который интегрирует большие языковые модели с обычным программным кодом через систему "плагинов" и "планировщиков". Он позволяет LLM вызывать нативные функции и оркестрировать рабочие процессы, эффективно обрабатывая модель как движок рассуждений в большем программном приложении. Его основная сила — бесшовная интеграция с существующими корпоративными кодовыми базами, особенно в .NET и Python средах. Концептуальные накладные расходы его архитектуры плагинов и планировщиков могут представить более крутую кривую обучения по сравнению с более простыми агентными фреймворками.

**Strands Agents**: Легковесный и гибкий SDK от AWS, который использует подход, управляемый моделью, для построения и запуска AI агентов. Он спроектирован быть простым и масштабируемым, поддерживая все от базовых разговорных ассистентов до сложных мульти-агентных автономных систем. Фреймворк не зависит от модели, предлагая широкую поддержку различных провайдеров LLM, и включает нативную интеграцию с MCP для легкого доступа к внешним инструментам. Его основное преимущество — простота и гибкость, с настраиваемым циклом агента, который легко начать использовать. Потенциальный компромисс заключается в том, что его легковесный дизайн означает, что разработчикам может потребоваться построить больше окружающей операционной инфраструктуры, такой как продвинутый мониторинг или системы управления жизненным циклом, которые более комплексные фреймворки могут предоставить из коробки.

## Заключение

Ландшафт агентных фреймворков предлагает разнообразный спектр инструментов, от низкоуровневых библиотек для определения логики агентов до высокоуровневых платформ для оркестрации мульти-агентного сотрудничества. На фундаментальном уровне LangChain позволяет простые, линейные рабочие процессы, в то время как LangGraph вводит состоятельные, циклические графы для более сложного рассуждения. Высокоуровневые фреймворки, такие как CrewAI и Google's ADK, смещают фокус на оркестрацию команд агентов с предопределенными ролями, в то время как другие, такие как LlamaIndex, специализируются на приложениях, интенсивных по данным. Это разнообразие представляет разработчикам основной компромисс между детальным контролем графовых систем и упрощенной разработкой более предвзятых платформ. Следовательно, выбор правильного фреймворка зависит от того, требует ли приложение простой последовательности, динамичного цикла рассуждений или управляемой команды специалистов. В конечном счете, эта развивающаяся экосистема позволяет разработчикам строить все более сложные AI системы, выбирая точный уровень абстракции, который требует их проект.

## Ссылки

1. [LangChain](https://www.langchain.com/)
2. [LangGraph](https://www.langchain.com/langgraph)
3. [Google's ADK](https://google.github.io/adk-docs/)
4. [Crew.AI](https://docs.crewai.com/en/introduction)

---

## Навигация

**Назад:** [Приложение B. Агентные взаимодействия ИИ от GUI до реального мира](Приложение%20B.%20Агентные%20взаимодействия%20ИИ%20от%20GUI%20до%20реального%20мира.md)
**Вперед:** [Приложение D. Создание агента с AgentSpace](Приложение%20D.%20Создание%20агента%20с%20AgentSpace.md)
