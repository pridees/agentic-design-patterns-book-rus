# Глава 20: Приоритизация

## Обзор паттерна

Приоритизация — способность агентов оценивать и упорядочивать задачи по важности, срочности и другим критериям для эффективного распределения ресурсов и достижения целей.

**Критерии приоритизации:**
- Важность задачи
- Срочность (дедлайны)
- Зависимости
- Ресурсные требования
- Бизнес-ценность

## Методы приоритизации

**1. Матрица Эйзенхауэра:**
- Срочное и важное → Немедленно
- Важное, не срочное → Запланировать
- Срочное, не важное → Делегировать
- Не срочное, не важное → Отклонить

**2. Взвешенная оценка:**
- Множественные критерии с весами
- Итоговый score = Σ(критерий × вес)

**3. MoSCoW:**
- Must have
- Should have
- Could have
- Won't have

**4. RICE:**
- Reach (охват)
- Impact (влияние)
- Confidence (уверенность)
- Effort (усилия)
- Score = (R × I × C) / E

## Практические применения

- **Проектное управление:** Приоритизация задач и фич
- **Поддержка клиентов:** Сортировка тикетов по важности
- **Контент-модерация:** Приоритет опасного контента
- **Кибербезопасность:** Ранжирование угроз
- **Персональные помощники:** Организация календаря

## Практический пример кода

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from dataclasses import dataclass
from typing import List

@dataclass
class Task:
    name: str
    description: str
    importance: int  # 1-10
    urgency: int  # 1-10
    effort: int  # в часах
    
    @property
    def priority_score(self):
        """Weighted score"""
        return (self.importance * 0.5 + self.urgency * 0.3) / (self.effort * 0.2)

class PrioritizationAgent:
    def __init__(self):
        self.llm = ChatOpenAI(model="gpt-4o", temperature=0)
    
    def evaluate_task(self, task_description):
        """LLM оценивает важность и срочность"""
        eval_prompt = ChatPromptTemplate.from_template(
            """Оцени задачу:
            
            Задача: {task}
            
            Верни JSON:
            {{
              "importance": 1-10,
              "urgency": 1-10,
              "estimated_effort": hours
            }}"""
        )
        
        result = (eval_prompt | self.llm).invoke({"task": task_description})
        
        import json
        return json.loads(result.content)
    
    def prioritize_tasks(self, tasks: List[Task]):
        """Сортировка по приоритету"""
        return sorted(tasks, key=lambda t: t.priority_score, reverse=True)
    
    def eisenhower_matrix(self, tasks: List[Task]):
        """Матрица Эйзенхауэра"""
        matrix = {
            "urgent_important": [],
            "important_not_urgent": [],
            "urgent_not_important": [],
            "neither": []
        }
        
        for task in tasks:
            urgent = task.urgency >= 7
            important = task.importance >= 7
            
            if urgent and important:
                matrix["urgent_important"].append(task)
            elif important and not urgent:
                matrix["important_not_urgent"].append(task)
            elif urgent and not important:
                matrix["urgent_not_important"].append(task)
            else:
                matrix["neither"].append(task)
        
        return matrix

# Использование
agent = PrioritizationAgent()

tasks = [
    Task("Баг в продакшене", "Критическая ошибка", 10, 10, 2),
    Task("Новая фича", "Улучшение UX", 7, 3, 8),
    Task("Документация", "Обновить README", 5, 4, 1),
    Task("Рефакторинг", "Улучшить код", 6, 2, 12)
]

# Приоритизация
prioritized = agent.prioritize_tasks(tasks)
matrix = agent.eisenhower_matrix(tasks)

print("Порядок выполнения:")
for i, task in enumerate(prioritized, 1):
    print(f"{i}. {task.name} (Score: {task.priority_score:.2f})")

print("\nМатрица Эйзенхауэра:")
for category, tasks in matrix.items():
    print(f"{category}: {[t.name for t in tasks]}")
```

## Динамическая приоритизация

**Факторы пересчёта:**
- Изменение дедлайнов
- Новые зависимости
- Изменение ресурсов
- Внешние события
- Feedback пользователей

## Ключевые выводы

- Приоритизация оптимизирует распределение ресурсов
- Матрица Эйзенхауэра для срочности/важности
- Взвешенная оценка для множественных критериев
- LLM помогает оценивать задачи
- Динамическая пересортировка при изменениях
- Критично для проектного управления, поддержки, безопасности
- Балансирует важность, срочность и усилия
