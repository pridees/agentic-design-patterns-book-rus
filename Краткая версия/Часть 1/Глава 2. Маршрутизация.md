# Глава 2: Маршрутизация

## Обзор паттерна

Маршрутизация добавляет условную логику в агентные системы, позволяя динамически выбирать между несколькими действиями в зависимости от входных данных, состояния или контекста. В отличие от линейных цепочек промптов, маршрутизация обеспечивает адаптивное поведение.

**Пример:** Агент поддержки анализирует запрос и направляет его:
- «Статус заказа» → база данных заказов
- «Информация о продукте» → каталог товаров
- «Техподдержка» → руководства или эскалация
- Неясное намерение → уточнение

## Механизмы маршрутизации

1. **LLM-маршрутизация:** Модель анализирует вход и возвращает категорию для маршрутизации

2. **Эмбеддинги:** Запрос переводится в вектор и сравнивается с векторами маршрутов по семантической близости

3. **Правила:** If-else логика на основе ключевых слов или паттернов (быстро, но менее гибко)

4. **ML-классификатор:** Специально обученная модель для задачи маршрутизации

Фреймворки LangChain, LangGraph и Google ADK предоставляют инструменты для реализации маршрутизации. LangGraph особенно удобен благодаря архитектуре графа состояний.

## Практические применения

- **Виртуальные ассистенты:** Интерпретация намерений и выбор действия (поиск, эскалация, учебный модуль)

- **Обработка данных:** Классификация входящих документов и направление в соответствующие рабочие процессы

- **Мультиагентные системы:** Диспетчеризация задач между специализированными агентами (поиск, суммаризация, анализ)

- **Ассистенты программирования:** Определение языка и намерения (отладка, объяснение, перевод) для выбора инструмента

## Практический пример кода

```python
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnableBranch

llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0)

# Симуляция обработчиков
def booking_handler(request: str) -> str:
    return f"Бронирование: '{request}'"

def info_handler(request: str) -> str:
    return f"Информация: '{request}'"

def unclear_handler(request: str) -> str:
    return f"Неясный запрос: '{request}'. Уточните."

# Роутер-промпт
coordinator_router_prompt = ChatPromptTemplate.from_messages([
    ("system", """Определи категорию запроса:
     - 'booker' для бронирования
     - 'info' для общей информации
     - 'unclear' если непонятно"""),
    ("user", "{request}")
])

router_chain = coordinator_router_prompt | llm | StrOutputParser()

# Условное ветвление
def route_request(router_output: str, original_request: str):
    intent = router_output.strip().lower()
    if "booker" in intent:
        return booking_handler(original_request)
    elif "info" in intent:
        return info_handler(original_request)
    else:
        return unclear_handler(original_request)

# Выполнение
request = "Забронируй отель в Париже"
intent = router_chain.invoke({"request": request})
result = route_request(intent, request)
print(result)
```

## Ключевые выводы

- Маршрутизация вводит условную логику для динамического выбора пути исполнения
- Может быть реализована через LLM, эмбеддинги, правила или ML-классификаторы
- Критична для адаптивных систем, обрабатывающих разнородные входы
- LangGraph и ADK предоставляют структурированные средства управления маршрутизацией
- Позволяет агентам разумно ориентироваться в различных сценариях

## Ссылки

1. [LangGraph](https://www.langchain.com/)
2. [Google ADK](https://google.github.io/adk-docs/)
