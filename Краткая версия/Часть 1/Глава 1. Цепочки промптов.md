# Глава 1: Цепочки промптов

## Обзор паттерна

Цепочки промптов (Pipeline) — паттерн для решения сложных задач через декомпозицию на последовательность мелких подзадач. Вместо одного монолитного промпта задача разбивается на управляемые шаги, где выход каждого становится входом следующего. Это создаёт модульный процесс с чёткой передачей контекста между этапами.

Паттерн позволяет интегрировать внешние инструменты и API на каждом шаге, расширяя возможности LLM за пределы обучающих данных. Это фундамент для построения сложных ИИ-агентов с многошаговым рассуждением и планированием.

**Проблемы одиночных промптов:** Сложный промпт ведёт к пропуску инструкций, дрейфу контекста, накоплению ошибок и галлюцинациям из-за когнитивной перегрузки модели.

**Решение через декомпозицию:** Разбиение задачи на фокусированные шаги повышает точность. Например, анализ отчёта:
1. Суммаризация ключевых выводов
2. Выделение трендов с данными
3. Составление письма на основе трендов

**Структурированный выход:** Для надёжности используйте JSON или XML между шагами:

```json
{
  "trends": [
    {
      "trend_name": "AI-Powered Personalization",
      "supporting_data": "73% предпочитают персонализацию"
    }
  ]
}
```

## Практические применения

1. **Обработка информации:** Извлечение текста → суммаризация → извлечение сущностей → поиск в базе → генерация отчёта

2. **Сложные вопросы:** Декомпозиция вопроса → исследование подзадач → синтез информации

3. **Извлечение данных:** Извлечение полей → валидация → доизвлечение при ошибках → итоговый вывод

4. **Генерация контента:** Генерация идей → создание плана → написание разделов → редактура

5. **Диалоговые агенты:** Обработка высказывания → выделение интента → обновление состояния → генерация ответа

6. **Генерация кода:** Псевдокод → первичный код → выявление ошибок → улучшение → документация

7. **Мультимодальный анализ:** Извлечение текста из изображения → сопоставление с метаданными → интерпретация

## Практический пример кода

Фреймворки LangChain, LangGraph и Google ADK упрощают построение цепочек. Пример двухшаговой цепочки:

```python
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser

llm = ChatOpenAI(temperature=0)

prompt_extract = ChatPromptTemplate.from_template(
  "Extract technical specifications:\n\n{text_input}"
)

prompt_transform = ChatPromptTemplate.from_template(
  "Transform to JSON with 'cpu', 'memory', 'storage':\n\n{specifications}"
)

extraction_chain = prompt_extract | llm | StrOutputParser()

full_chain = (
  {"specifications": extraction_chain}
  | prompt_transform | llm | StrOutputParser()
)

input_text = "Laptop: 3.5 GHz octa-core, 16GB RAM, 1TB SSD."
result = full_chain.invoke({"text_input": input_text})
print(result)
```

## Инжиниринг контекста

Инжиниринг контекста — систематическое построение информационной среды для модели, включая системный промпт, внешние данные и неявную информацию (история, состояние). Качество контекста критично для производительности агентов.

Инструменты как Vertex AI Prompt Optimizer автоматически улучшают промпты на тестовых наборах, адаптируя их под разные модели без ручной работы.

## Ключевые выводы

- Цепочки промптов разбивают задачи на последовательность сфокусированных шагов
- Выход каждого шага — вход следующего
- Паттерн повышает надёжность и управляемость
- LangChain/LangGraph и ADK предоставляют инструменты для многошаговых процессов
- Применяйте при многоэтапных задачах, интеграции инструментов и агентных системах

## Ссылки

1. [LangChain LCEL](https://python.langchain.com/v0.2/docs/core_modules/expression_language/)
2. [LangGraph](https://langchain-ai.github.io/langgraph/)
3. [Prompt Engineering Guide](https://www.promptingguide.ai/techniques/chaining)
4. [Vertex Prompt Optimizer](https://cloud.google.com/vertex-ai/generative-ai/docs/learn/prompts/prompt-optimizer)
