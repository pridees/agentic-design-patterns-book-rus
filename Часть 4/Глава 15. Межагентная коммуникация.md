# Глава 15: Межагентное взаимодействие (A2A)

Отдельные агенты ИИ часто сталкиваются с ограничениями при решении сложных многогранных проблем, даже обладая продвинутыми возможностями. Для преодоления этого межагентное взаимодействие (A2A) позволяет различным агентам ИИ, потенциально построенным с использованием разных frameworks, эффективно сотрудничать. Это сотрудничество включает бесшовную координацию, делегирование задач и обмен информацией.

Протокол A2A от Google представляет собой открытый стандарт, предназначенный для обеспечения такого универсального взаимодействия. В этой главе мы рассмотрим A2A, его практические применения и реализацию в рамках Google ADK.

# Обзор паттерна межагентного взаимодействия

Протокол Agent2Agent (A2A) представляет собой открытый стандарт, предназначенный для обеспечения взаимодействия и сотрудничества между различными frameworks агентов ИИ. Он обеспечивает совместимость, позволяя агентам ИИ, разработанным с использованием таких технологий, как LangGraph, CrewAI или Google ADK, работать вместе независимо от их происхождения или различий в frameworks.

A2A поддерживается рядом технологических компаний и поставщиков услуг, включая Atlassian, Box, LangChain, MongoDB, Salesforce, SAP и ServiceNow. Microsoft планирует интегрировать A2A в Azure AI Foundry и Copilot Studio, демонстрируя свою приверженность открытым протоколам. Кроме того, Auth0 и SAP интегрируют поддержку A2A в свои платформы и агентов.

Как протокол с открытым исходным кодом, A2A приветствует вклад сообщества для содействия его развитию и широкому внедрению.

## Основные концепции A2A

Протокол A2A предоставляет структурированный подход к взаимодействию агентов, основанный на нескольких ключевых концепциях. Тщательное понимание этих концепций имеет решающее значение для всех, кто разрабатывает или интегрируется с A2A-совместимыми системами. Основными столпами A2A являются основные участники, Agent Card, обнаружение агентов, коммуникация и задачи, механизмы взаимодействия и безопасность, все из которых будут рассмотрены подробно.

**Основные участники:** A2A включает три основные сущности:

- User: инициирует запросы на помощь агента.
- A2A Client (агент-клиент): приложение или агент ИИ, который действует от имени пользователя для запроса действий или информации.
- A2A Server (удаленный агент): агент ИИ или система, которая предоставляет HTTP endpoint для обработки запросов клиентов и возврата результатов. Удаленный агент работает как "непрозрачная" система, что означает, что клиенту не нужно понимать детали его внутренней работы.

**Agent Card:** Цифровая идентичность агента определяется его Agent Card, обычно JSON-файлом. Этот файл содержит ключевую информацию для взаимодействия с клиентом и автоматического обнаружения, включая идентичность агента, URL endpoint и версию. Он также детализирует поддерживаемые возможности, такие как streaming или push-уведомления, специфические навыки, режимы ввода/вывода по умолчанию и требования аутентификации. Ниже приведен пример Agent Card для WeatherBot.

```json
{
  "name": "WeatherBot",
  "description": "Provides accurate weather forecasts and historical data.",
  "url": "http://weather-service.example.com/a2a",
  "version": "1.0.0",
  "capabilities": {
    "streaming": true,
    "pushNotifications": false,
    "stateTransitionHistory": true
  },
  "authentication": {
    "schemes": ["apiKey"]
  },
  "defaultInputModes": ["text"],
  "defaultOutputModes": ["text"],
  "skills": [
    {
      "id": "get_current_weather",
      "name": "Get Current Weather",
      "description": "Retrieve real-time weather for any location.",
      "inputModes": ["text"],
      "outputModes": ["text"],
      "examples": [
        "What's the weather in Paris?",
        "Current conditions in Tokyo"
      ],
      "tags": ["weather", "current", "real-time"]
    },
    {
      "id": "get_forecast",
      "name": "Get Forecast",
      "description": "Get 5-day weather predictions.",
      "inputModes": ["text"],
      "outputModes": ["text"],
      "examples": [
        "5-day forecast for New York",
        "Will it rain in London this weekend?"
      ],
      "tags": ["weather", "forecast", "prediction"]
    }
  ]
}
```

**Обнаружение агентов:** позволяет клиентам находить Agent Cards, которые описывают возможности доступных A2A серверов. Для этого процесса существует несколько стратегий:

- **Well-Known URI:** Агенты размещают свою Agent Card по стандартизированному пути (например, /.well-known/agent.json). Этот подход обеспечивает широкую, часто автоматизированную доступность для публичного или доменно-специфического использования.
- **Кураторские реестры:** Они предоставляют централизованный каталог, где Agent Cards публикуются и могут быть запрошены на основе конкретных критериев. Это хорошо подходит для корпоративных сред, требующих централизованного управления и контроля доступа.
- **Прямая конфигурация:** Информация Agent Card встраивается или передается в частном порядке. Этот метод подходит для тесно связанных или частных систем, где динамическое обнаружение не является критичным.

Независимо от выбранного метода, важно обеспечить безопасность endpoints Agent Card. Это может быть достигнуто через контроль доступа, взаимный TLS (mTLS) или сетевые ограничения, особенно если карта содержит чувствительную (хотя и не секретную) информацию.

**Коммуникация и задачи:** В framework A2A коммуникация структурирована вокруг асинхронных задач, которые представляют фундаментальные единицы работы для долго выполняющихся процессов. Каждой задаче присваивается уникальный идентификатор, и она проходит через серию состояний — таких как submitted, working или completed — дизайн, который поддерживает параллельную обработку в сложных операциях. Коммуникация между агентами происходит через сообщение (Message).

Эта коммуникация содержит атрибуты, которые являются метаданными ключ-значение, описывающими сообщение (например, его приоритет или время создания), и одну или несколько частей, которые несут фактический контент, доставляемый, такой как простой текст, файлы или структурированные JSON данные. Материальные выходы, генерируемые агентом во время задачи, называются артефактами. Как и сообщения, артефакты также состоят из одной или нескольких частей и могут передаваться инкрементально по мере поступления результатов. Вся коммуникация в рамках A2A framework проводится по HTTP(S) с использованием протокола JSON-RPC 2.0 для payloads. Для поддержания непрерывности через множественные взаимодействия используется генерируемый сервером contextId для группировки связанных задач и сохранения контекста.

**Механизмы взаимодействия:** Request/Response (Polling), Server-Sent Events (SSE). A2A предоставляет множественные методы взаимодействия для удовлетворения различных потребностей ИИ приложений, каждый со своим отличительным механизмом:

- **Синхронный Request/Response:** Для быстрых, немедленных операций. В этой модели клиент отправляет запрос и активно ждет, пока сервер обработает его и вернет полный ответ в одном синхронном обмене.
- **Асинхронный Polling:** Подходит для задач, которые занимают больше времени для обработки. Клиент отправляет запрос, и сервер немедленно подтверждает его со статусом "working" и ID задачи. Клиент затем свободен выполнять другие действия и может периодически опрашивать сервер, отправляя новые запросы для проверки статуса задачи, пока она не будет помечена как "completed" или "failed".
- **Streaming обновления (Server-Sent Events - SSE):** Идеально для получения real-time, инкрементальных результатов. Этот метод устанавливает постоянное, одностороннее соединение от сервера к клиенту. Он позволяет удаленному агенту непрерывно отправлять обновления, такие как изменения статуса или частичные результаты, без необходимости клиенту делать множественные запросы.
- **Push уведомления (Webhooks):** Предназначены для очень долго выполняющихся или ресурсоемких задач, где поддержание постоянного соединения или частый polling неэффективен. Клиент может зарегистрировать webhook URL, и сервер отправит асинхронное уведомление ("push") на этот URL, когда статус задачи значительно изменится (например, при завершении).

Agent Card указывает, поддерживает ли агент streaming или push notification возможности. Кроме того, A2A является модально-агностическим, что означает, что он может облегчить эти паттерны взаимодействия не только для текста, но и для других типов данных, таких как аудио и видео, обеспечивая богатые, мультимодальные ИИ приложения. Как streaming, так и push notification возможности указываются в Agent Card.

```json
# Пример синхронного запроса
{
  "jsonrpc": "2.0",
  "id": "1",
  "method": "sendTask",
  "params": {
    "id": "task-001",
    "sessionId": "session-001",
    "message": {
      "role": "user",
      "parts": [
        {
          "type": "text",
          "text": "What is the exchange rate from USD to EUR?"
        }
      ]
    },
    "acceptedOutputModes": ["text/plain"],
    "historyLength": 5
  }
}
```

Синхронный запрос использует метод sendTask, где клиент запрашивает и ожидает единый, полный ответ на свой запрос. В отличие от этого, streaming запрос использует метод sendTaskSubscribe для установления постоянного соединения, позволяя агенту отправлять обратно множественные, инкрементальные обновления или частичные результаты с течением времени.

```json
# Пример Streaming запроса
{
  "jsonrpc": "2.0",
  "id": "2",
  "method": "sendTaskSubscribe",
  "params": {
    "id": "task-002",
    "sessionId": "session-001",
    "message": {
      "role": "user",
      "parts": [
        {
          "type": "text",
          "text": "What's the exchange rate for JPY to GBP today?"
        }
      ]
    },
    "acceptedOutputModes": ["text/plain"],
    "historyLength": 5
  }
}
```

**Безопасность:** Межагентное взаимодействие (A2A) является жизненно важным компонентом архитектуры системы, обеспечивающим безопасный и бесшовный обмен данными между агентами. Оно обеспечивает надежность и целостность через несколько встроенных механизмов.

Взаимная безопасность транспортного уровня (TLS): Устанавливаются зашифрованные и аутентифицированные соединения для предотвращения несанкционированного доступа и перехвата данных, обеспечивая безопасную коммуникацию.

Комплексные журналы аудита: Все межагентные коммуникации тщательно записываются, детализируя поток информации, участвующих агентов и действия. Этот аудиторский след имеет решающее значение для подотчетности, устранения неполадок и анализа безопасности.

Декларация Agent Card: Требования аутентификации явно декларируются в Agent Card, конфигурационном артефакте, описывающем идентичность агента, возможности и политики безопасности. Это централизует и упрощает управление аутентификацией.

Обработка учетных данных: Агенты обычно аутентифицируются с использованием безопасных учетных данных, таких как OAuth 2.0 токены или API ключи, передаваемые через HTTP заголовки. Этот метод предотвращает выставление учетных данных в URLs или телах сообщений, повышая общую безопасность.

## A2A vs. MCP

A2A является протоколом, который дополняет Model Context Protocol (MCP) от Anthropic (см. Рис. 1). В то время как MCP фокусируется на структурировании контекста для агентов и их взаимодействии с внешними данными и инструментами, A2A облегчает координацию и коммуникацию между агентами, обеспечивая делегирование задач и сотрудничество.

![][image2]

Рис.1: Сравнение протоколов A2A и MCP

Цель A2A — повысить эффективность, снизить затраты на интеграцию и способствовать инновациям и совместимости в разработке сложных мультиагентных систем ИИ. Поэтому тщательное понимание основных компонентов A2A и операционных методов является существенным для его эффективного проектирования, реализации и применения в построении совместных и совместимых систем агентов ИИ.

# Практические применения и сценарии использования

Межагентное взаимодействие незаменимо для построения сложных решений ИИ в различных областях, обеспечивая модульность, масштабируемость и расширенный интеллект.

- **Сотрудничество между frameworks:** Основной сценарий использования A2A — обеспечение независимых агентов ИИ, независимо от их базовых frameworks (например, ADK, LangChain, CrewAI), для коммуникации и сотрудничества. Это фундаментально для построения сложных мультиагентных систем, где различные агенты специализируются на разных аспектах проблемы.
- **Автоматизированная оркестрация рабочих процессов:** В корпоративных условиях A2A может облегчить сложные рабочие процессы, позволяя агентам делегировать и координировать задачи. Например, агент может обрабатывать первоначальный сбор данных, затем делегировать другому агенту для анализа, и наконец третьему для генерации отчета, все коммуницируя через протокол A2A.
- **Динамическое извлечение информации:** Агенты могут коммуницировать для извлечения и обмена информацией в реальном времени. Основной агент может запросить живые рыночные данные у специализированного "агента извлечения данных", который затем использует внешние API для сбора информации и отправки ее обратно.

# Практический пример кода

Давайте рассмотрим практические применения протокола A2A. Репозиторий по адресу https://github.com/google-a2a/a2a-samples/tree/main/samples предоставляет примеры на Java, Go и Python, которые иллюстрируют, как различные frameworks агентов, такие как LangGraph, CrewAI, Azure AI Foundry и AG2, могут коммуницировать с использованием A2A. Весь код в этом репозитории выпущен под лицензией Apache 2.0. Для дальнейшей иллюстрации основных концепций A2A мы рассмотрим фрагменты кода, фокусирующиеся на настройке A2A сервера с использованием агента на основе ADK с инструментами, аутентифицированными Google. Рассматривая https://github.com/google-a2a/a2a-samples/blob/main/samples/python/agents/birthday_planner_adk/calendar_agent/adk_agent.py

```python
import datetime
from google.adk.agents import LlmAgent  # type: ignore[import-untyped]
from google.adk.tools.google_api_tool import CalendarToolset  # type: ignore[import-untyped]


async def create_agent(client_id, client_secret) -> LlmAgent:
    """Constructs the ADK agent."""
    toolset = CalendarToolset(client_id=client_id, client_secret=client_secret)
    return LlmAgent(
        model='gemini-2.0-flash-001',
        name='calendar_agent',
        description="An agent that can help manage a user's calendar",
        instruction=f"""
You are an agent that can help manage a user's calendar.

Users will request information about the state of their calendar
or to make changes to their calendar. Use the provided tools for interacting with the calendar API.

If not specified, assume the calendar the user wants is the 'primary' calendar.

When using the Calendar API tools, use well-formed RFC3339 timestamps.

Today is {datetime.datetime.now()}.
""",
        tools=await toolset.get_tools(),
    )
```

Этот код Python определяет асинхронную функцию `create_agent`, которая конструирует ADK LlmAgent. Он начинает с инициализации `CalendarToolset`, используя предоставленные учетные данные клиента для доступа к Google Calendar API. Затем создается экземпляр `LlmAgent`, настроенный с указанной моделью Gemini, описательным именем и инструкциями для управления календарем пользователя. Агент оснащен инструментами календаря из `CalendarToolset`, позволяя ему взаимодействовать с Calendar API и отвечать на пользовательские запросы относительно состояний календаря или модификаций. Инструкции агента динамически включают текущую дату для временного контекста. Чтобы проиллюстрировать, как агент конструируется, давайте рассмотрим ключевую секцию из calendar_agent, найденного в примерах A2A на GitHub.

Код ниже показывает, как агент определяется со своими специфическими инструкциями и инструментами. Обратите внимание, что показан только код, необходимый для объяснения этой функциональности; вы можете получить доступ к полному файлу здесь: https://github.com/a2aproject/a2a-samples/blob/main/samples/python/agents/birthday_planner_adk/calendar_agent/__main__.py

```python
def main(host: str, port: int):
    # Verify an API key is set.
    # Not required if using Vertex AI APIs.
    if os.getenv('GOOGLE_GENAI_USE_VERTEXAI') != 'TRUE' and not os.getenv(
        'GOOGLE_API_KEY'
    ):
        raise ValueError(
            'GOOGLE_API_KEY environment variable not set and '
            'GOOGLE_GENAI_USE_VERTEXAI is not TRUE.'
        )

    skill = AgentSkill(
        id='check_availability',
        name='Check Availability',
        description="Checks a user's availability for a time using their Google Calendar",
        tags=['calendar'],
        examples=['Am I free from 10am to 11am tomorrow?'],
    )

    agent_card = AgentCard(
        name='Calendar Agent',
        description="An agent that can manage a user's calendar",
        url=f'http://{host}:{port}/',
        version='1.0.0',
        defaultInputModes=['text'],
        defaultOutputModes=['text'],
        capabilities=AgentCapabilities(streaming=True),
        skills=[skill],
    )

    adk_agent = asyncio.run(create_agent(
        client_id=os.getenv('GOOGLE_CLIENT_ID'),
        client_secret=os.getenv('GOOGLE_CLIENT_SECRET'),
    ))
    runner = Runner(
        app_name=agent_card.name,
        agent=adk_agent,
        artifact_service=InMemoryArtifactService(),
        session_service=InMemorySessionService(),
        memory_service=InMemoryMemoryService(),
    )
    agent_executor = ADKAgentExecutor(runner, agent_card)

    async def handle_auth(request: Request) -> PlainTextResponse:
        await agent_executor.on_auth_callback(
            str(request.query_params.get('state')), str(request.url)
        )
        return PlainTextResponse('Authentication successful.')

    request_handler = DefaultRequestHandler(
        agent_executor=agent_executor, task_store=InMemoryTaskStore()
    )

    a2a_app = A2AStarletteApplication(
        agent_card=agent_card, http_handler=request_handler
    )
    routes = a2a_app.routes()
    routes.append(
        Route(
            path='/authenticate',
            methods=['GET'],
            endpoint=handle_auth,
        )
    )
    app = Starlette(routes=routes)

    uvicorn.run(app, host=host, port=port)


if __name__ == '__main__':
    main()
```

Этот код Python демонстрирует настройку A2A-совместимого "Calendar Agent" для проверки доступности пользователя с использованием Google Calendar. Он включает проверку API ключей или конфигураций Vertex AI для целей аутентификации. Возможности агента, включая навык "check_availability", определяются в AgentCard, которая также указывает сетевой адрес агента. Затем создается ADK агент, настроенный с сервисами в памяти для управления артефактами, сессиями и памятью. Код затем инициализирует веб-приложение Starlette, включает callback аутентификации и обработчик протокола A2A, и выполняет его с использованием Uvicorn для выставления агента через HTTP.

Эти примеры иллюстрируют процесс построения A2A-совместимого агента, от определения его возможностей до запуска его как веб-сервиса. Используя Agent Cards и ADK, разработчики могут создавать совместимые агенты ИИ, способные интегрироваться с инструментами типа Google Calendar. Этот практический подход демонстрирует применение A2A в установлении мультиагентной экосистемы.

Дальнейшее изучение A2A рекомендуется через демонстрацию кода на https://www.trickle.so/blog/how-to-build-google-a2a-project. Ресурсы, доступные по этой ссылке, включают примеры A2A клиентов и серверов на Python и JavaScript, мультиагентные веб-приложения, интерфейсы командной строки и примеры реализаций для различных frameworks агентов.

# Краткий обзор

**Что:** Отдельные агенты ИИ, особенно те, которые построены на разных frameworks, часто испытывают трудности со сложными, многогранными проблемами самостоятельно. Основная проблема — это отсутствие общего языка или протокола, который позволяет им эффективно коммуницировать и сотрудничать. Эта изоляция препятствует созданию сложных систем, где множественные специализированные агенты могут объединить свои уникальные навыки для решения больших задач. Без стандартизированного подхода интеграция этих разрозненных агентов является дорогостоящей, времязатратной и препятствует развитию более мощных, связных решений ИИ.

**Почему:** Протокол межагентного взаимодействия (A2A) предоставляет открытое, стандартизированное решение для этой проблемы. Это HTTP-основанный протокол, который обеспечивает совместимость, позволяя различным агентам ИИ координировать, делегировать задачи и делиться информацией бесшовно, независимо от их базовой технологии. Основным компонентом является Agent Card, файл цифровой идентичности, который описывает возможности агента, навыки и endpoints коммуникации, облегчая обнаружение и взаимодействие. A2A определяет различные механизмы взаимодействия, включая синхронную и асинхронную коммуникацию, для поддержки разнообразных сценариев использования. Создавая универсальный стандарт для сотрудничества агентов, A2A способствует модульной и масштабируемой экосистеме для построения сложных, мультиагентных агентных систем.

**Правило большого пальца:** Используйте этот паттерн, когда вам нужно оркестрировать сотрудничество между двумя или более агентами ИИ, особенно если они построены с использованием разных frameworks (например, Google ADK, LangGraph, CrewAI). Он идеален для построения сложных, модульных приложений, где специализированные агенты обрабатывают специфические части рабочего процесса, такие как делегирование анализа данных одному агенту и генерации отчета другому. Этот паттерн также существенен, когда агенту нужно динамически обнаруживать и потреблять возможности других агентов для завершения задачи.

**Визуальное резюме**

![][image1]

Рис.2: Паттерн межагентного взаимодействия A2A

# Ключевые выводы

- Протокол Google A2A является открытым, HTTP-основанным стандартом, который облегчает коммуникацию и сотрудничество между агентами ИИ, построенными с разными frameworks.
- AgentCard служит цифровым идентификатором агента, позволяя автоматическое обнаружение и понимание его возможностей другими агентами.
- A2A предлагает как синхронные request-response взаимодействия (используя `tasks/send`), так и streaming обновления (используя `tasks/sendSubscribe`) для удовлетворения различных потребностей коммуникации.
- Протокол поддерживает мультитурные разговоры, включая состояние `input-required`, которое позволяет агентам запрашивать дополнительную информацию и поддерживать контекст во время взаимодействий.
- A2A поощряет модульную архитектуру, где специализированные агенты могут работать независимо на разных портах, обеспечивая масштабируемость и распределенность системы.
- Инструменты типа Trickle AI помогают в визуализации и отслеживании A2A коммуникаций, что помогает разработчикам мониторить, отлаживать и оптимизировать мультиагентные системы.
- В то время как A2A является высокоуровневым протоколом для управления задачами и рабочими процессами между различными агентами, Model Context Protocol (MCP) предоставляет стандартизированный интерфейс для LLM для взаимодействия с внешними ресурсами.

# Заключение

Протокол межагентного взаимодействия (A2A) устанавливает жизненно важный, открытый стандарт для преодоления присущей изоляции отдельных агентов ИИ. Предоставляя общий HTTP-основанный framework, он обеспечивает бесшовное сотрудничество и совместимость между агентами, построенными на разных платформах, таких как Google ADK, LangGraph или CrewAI. Основным компонентом является Agent Card, которая служит цифровой идентичностью, четко определяя возможности агента и обеспечивая динамическое обнаружение другими агентами. Гибкость протокола поддерживает различные паттерны взаимодействия, включая синхронные запросы, асинхронный polling и streaming в реальном времени, удовлетворяя широкий спектр потребностей приложений.

Это обеспечивает создание модульных и масштабируемых архитектур, где специализированные агенты могут быть объединены для оркестрации сложных автоматизированных рабочих процессов. Безопасность является фундаментальным аспектом, с встроенными механизмами типа mTLS и явными требованиями аутентификации для защиты коммуникаций. Дополняя другие стандарты типа MCP, уникальный фокус A2A на высокоуровневой координации и делегировании задач между агентами. Сильная поддержка от крупных технологических компаний и доступность практических реализаций подчеркивают его растущую важность. Этот протокол прокладывает путь разработчикам для построения более сложных, распределенных и интеллектуальных мультиагентных систем. В конечном итоге, A2A является фундаментальным столпом для создания инновационной и совместимой экосистемы совместного ИИ.

# Литература

1. Chen, B. (2025, April 22). _How to Build Your First Google A2A Project: A Step-by-Step Tutorial_. Trickle.so Blog. https://www.trickle.so/blog/how-to-build-google-a2a-project
2. Google A2A GitHub Repository. https://github.com/google-a2a/A2A
3. Google Agent Development Kit (ADK) https://google.github.io/adk-docs/
4. Getting Started with Agent-to-Agent (A2A) Protocol: https://codelabs.developers.google.com/intro-a2a-purchasing-concierge#0
5. Google AgentDiscovery - https://a2a-protocol.org/latest/
6. Communication between different AI frameworks such as LangGraph, CrewAI, and Google ADK https://www.trickle.so/blog/how-to-build-google-a2a-project
7. Designing Collaborative Multi-Agent Systems with the A2A Protocol https://www.oreilly.com/radar/designing-collaborative-multi-agent-systems-with-the-a2a-protocol/

[image1]: ../Assets/chapter-15-image1.png
[image2]: ../Assets/chapter-15-image2.png

---

## Навигация

**Назад:** [Глава 14. Извлечение знаний](../../Часть%203/Глава%2014.%20Извлечение%20знаний.md)  
**Вперед:** [Глава 16. Оптимизация с учетом ресурсов](Глава%2016.%20Оптимизация%20с%20учетом%20ресурсов.md)
