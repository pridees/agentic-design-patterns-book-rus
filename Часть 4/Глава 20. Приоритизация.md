# Глава 20: Приоритизация

В сложных, динамических средах агенты часто сталкиваются с многочисленными потенциальными действиями, конфликтующими целями и ограниченными ресурсами. Без определенного процесса для определения последующего действия агенты могут испытывать снижение эффективности, операционные задержки или неспособность достичь ключевых целей. Шаблон приоритизации решает эту проблему, позволяя агентам оценивать и ранжировать задачи, цели или действия на основе их значимости, срочности, зависимостей и установленных критериев. Это обеспечивает концентрацию усилий агентов на наиболее критических задачах, что приводит к повышению эффективности и согласованности с целями.

## Обзор шаблона приоритизации

Агенты используют приоритизацию для эффективного управления задачами, целями и подцелями, определяя последующие действия. Этот процесс способствует принятию обоснованных решений при работе с множественными требованиями, отдавая приоритет жизненно важным или срочным действиям над менее критическими. Он особенно актуален в реальных сценариях, где ресурсы ограничены, время лимитировано, а цели могут конфликтовать.

Фундаментальные аспекты приоритизации агентов обычно включают несколько элементов. Во-первых, определение критериев устанавливает правила или метрики для оценки задач. Они могут включать срочность (временную чувствительность задачи), важность (влияние на основную цель), зависимости (является ли задача предпосылкой для других), доступность ресурсов (готовность необходимых инструментов или информации), анализ затрат/выгод (усилия против ожидаемого результата) и пользовательские предпочтения для персонализированных агентов. Во-вторых, оценка задач включает анализ каждой потенциальной задачи против этих определенных критериев, используя методы от простых правил до сложной оценки или рассуждений LLM. В-третьих, логика планирования или выбора относится к алгоритму, который на основе оценок выбирает оптимальное следующее действие или последовательность задач, потенциально используя очередь или продвинутый компонент планирования. Наконец, динамическая реприоритизация позволяет агенту изменять приоритеты при изменении обстоятельств, например, при появлении нового критического события или приближении крайнего срока, обеспечивая адаптивность и отзывчивость агента.

Приоритизация может происходить на различных уровнях: выбор общей цели (приоритизация целей высокого уровня), упорядочивание шагов в рамках плана (приоритизация подзадач) или выбор следующего непосредственного действия из доступных вариантов (выбор действия). Эффективная приоритизация позволяет агентам демонстрировать более интеллектуальное, эффективное и устойчивое поведение, особенно в сложных, многоцелевых средах. Это отражает организацию человеческих команд, где менеджеры приоритизируют задачи, учитывая вклад всех участников.

## Практические применения и случаи использования

В различных реальных приложениях AI агенты демонстрируют сложное использование приоритизации для принятия своевременных и эффективных решений.

- **Автоматизированная поддержка клиентов**: Агенты приоритизируют срочные запросы, такие как отчеты о сбоях системы, над рутинными вопросами, такими как сброс паролей. Они также могут отдавать предпочтение клиентам высокой ценности.

- **Облачные вычисления**: AI управляет и планирует ресурсы, приоритизируя распределение критически важным приложениям в периоды пиковой нагрузки, в то время как менее срочные пакетные задания откладываются на непиковые часы для оптимизации затрат.

- **Системы автономного вождения**: Постоянно приоритизируют действия для обеспечения безопасности и эффективности. Например, торможение для избежания столкновения имеет приоритет над поддержанием дисциплины движения или оптимизацией расхода топлива.

- **Финансовая торговля**: Боты приоритизируют сделки, анализируя такие факторы, как рыночные условия, толерантность к риску, размер прибыли и новости в реальном времени, обеспечивая быстрое исполнение высокоприоритетных транзакций.

- **Управление проектами**: AI агенты приоритизируют задачи на проектной доске на основе крайних сроков, зависимостей, доступности команды и стратегической важности.

- **Кибербезопасность**: Агенты, мониторящие сетевой трафик, приоритизируют предупреждения, оценивая серьезность угрозы, потенциальное воздействие и критичность активов, обеспечивая немедленную реакцию на наиболее опасные угрозы.

- **Персональные помощники AI**: Используют приоритизацию для управления повседневной жизнью, организуя календарные события, напоминания и уведомления в соответствии с определенной пользователем важностью, приближающимися крайними сроками и текущим контекстом.

Эти примеры в совокупности иллюстрируют, как способность приоритизировать является фундаментальной для улучшения производительности и возможностей принятия решений AI агентов в широком спектре ситуаций.

## Практический пример кода

Следующий пример демонстрирует разработку AI агента-менеджера проектов с использованием LangChain. Этот агент облегчает создание, приоритизацию и назначение задач участникам команды, иллюстрируя применение больших языковых моделей с пользовательскими инструментами для автоматизированного управления проектами.

```python
import os
import asyncio
from typing import List, Optional, Dict, Type

from dotenv import load_dotenv
from pydantic import BaseModel, Field

from langchain_core.prompts import ChatPromptTemplate
from langchain_core.tools import Tool
from langchain_openai import ChatOpenAI
from langchain.agents import AgentExecutor, create_react_agent
from langchain.memory import ConversationBufferMemory

# --- 0. Configuration and Setup ---
# Loads the OPENAI_API_KEY from the .env file.
load_dotenv()

# The ChatOpenAI client automatically picks up the API key from the environment.
llm = ChatOpenAI(temperature=0.5, model="gpt-4o-mini")

# --- 1. Task Management System ---

class Task(BaseModel):
    """Represents a single task in the system."""
    id: str
    description: str
    priority: Optional[str] = None  # P0, P1, P2
    assigned_to: Optional[str] = None  # Name of the worker

class SuperSimpleTaskManager:
    """An efficient and robust in-memory task manager."""
    def __init__(self):
        # Use a dictionary for O(1) lookups, updates, and deletions.
        self.tasks: Dict[str, Task] = {}
        self.next_task_id = 1

    def create_task(self, description: str) -> Task:
        """Creates and stores a new task."""
        task_id = f"TASK-{self.next_task_id:03d}"
        new_task = Task(id=task_id, description=description)
        self.tasks[task_id] = new_task
        self.next_task_id += 1
        print(f"DEBUG: Task created - {task_id}: {description}")
        return new_task

    def update_task(self, task_id: str, **kwargs) -> Optional[Task]:
        """Safely updates a task using Pydantic's model_copy."""
        task = self.tasks.get(task_id)
        if task:
            # Use model_copy for type-safe updates.
            update_data = {k: v for k, v in kwargs.items() if v is not None}
            updated_task = task.model_copy(update=update_data)
            self.tasks[task_id] = updated_task
            print(f"DEBUG: Task {task_id} updated with {update_data}")
            return updated_task

        print(f"DEBUG: Task {task_id} not found for update.")
        return None

    def list_all_tasks(self) -> str:
        """Lists all tasks currently in the system."""
        if not self.tasks:
            return "No tasks in the system."

        task_strings = []
        for task in self.tasks.values():
            task_strings.append(
                f"ID: {task.id}, Desc: '{task.description}', "
                f"Priority: {task.priority or 'N/A'}, "
                f"Assigned To: {task.assigned_to or 'N/A'}"
            )
        return "Current Tasks:\n" + "\n".join(task_strings)

task_manager = SuperSimpleTaskManager()

# --- 2. Tools for the Project Manager Agent ---

# Use Pydantic models for tool arguments for better validation and clarity.
class CreateTaskArgs(BaseModel):
    description: str = Field(description="A detailed description of the task.")

class PriorityArgs(BaseModel):
    task_id: str = Field(description="The ID of the task to update, e.g., 'TASK-001'.")
    priority: str = Field(description="The priority to set. Must be one of: 'P0', 'P1', 'P2'.")

class AssignWorkerArgs(BaseModel):
    task_id: str = Field(description="The ID of the task to update, e.g., 'TASK-001'.")
    worker_name: str = Field(description="The name of the worker to assign the task to.")

def create_new_task_tool(description: str) -> str:
    """Creates a new project task with the given description."""
    task = task_manager.create_task(description)
    return f"Created task {task.id}: '{task.description}'."

def assign_priority_to_task_tool(task_id: str, priority: str) -> str:
    """Assigns a priority (P0, P1, P2) to a given task ID."""
    if priority not in ["P0", "P1", "P2"]:
        return "Invalid priority. Must be P0, P1, or P2."
    task = task_manager.update_task(task_id, priority=priority)
    return f"Assigned priority {priority} to task {task.id}." if task else f"Task {task_id} not found."

def assign_task_to_worker_tool(task_id: str, worker_name: str) -> str:
    """Assigns a task to a specific worker."""
    task = task_manager.update_task(task_id, assigned_to=worker_name)
    return f"Assigned task {task.id} to {worker_name}." if task else f"Task {task_id} not found."

# All tools the PM agent can use
pm_tools = [
    Tool(
        name="create_new_task",
        func=create_new_task_tool,
        description="Use this first to create a new task and get its ID.",
        args_schema=CreateTaskArgs
    ),
    Tool(
        name="assign_priority_to_task",
        func=assign_priority_to_task_tool,
        description="Use this to assign a priority to a task after it has been created.",
        args_schema=PriorityArgs
    ),
    Tool(
        name="assign_task_to_worker",
        func=assign_task_to_worker_tool,
        description="Use this to assign a task to a specific worker after it has been created.",
        args_schema=AssignWorkerArgs
    ),
    Tool(
        name="list_all_tasks",
        func=task_manager.list_all_tasks,
        description="Use this to list all current tasks and their status."
    ),
]

# --- 3. Project Manager Agent Definition ---

pm_prompt_template = ChatPromptTemplate.from_messages([
    ("system", """You are a focused Project Manager LLM agent. Your goal is to manage project tasks efficiently.

    When you receive a new task request, follow these steps:
    1.  First, create the task with the given description using the `create_new_task` tool. You must do this first to get a `task_id`.
    2.  Next, analyze the user's request to see if a priority or an assignee is mentioned.
        - If a priority is mentioned (e.g., "urgent", "ASAP", "critical"), map it to P0. Use `assign_priority_to_task`.
        - If a worker is mentioned, use `assign_task_to_worker`.
    3.  If any information (priority, assignee) is missing, you must make a reasonable default assignment (e.g., assign P1 priority and assign to 'Worker A').
    4.  Once the task is fully processed, use `list_all_tasks` to show the final state.

    Available workers: 'Worker A', 'Worker B', 'Review Team'
    Priority levels: P0 (highest), P1 (medium), P2 (lowest)
    """),
    ("placeholder", "{chat_history}"),
    ("human", "{input}"),
    ("placeholder", "{agent_scratchpad}")
])

# Create the agent executor
pm_agent = create_react_agent(llm, pm_tools, pm_prompt_template)
pm_agent_executor = AgentExecutor(
    agent=pm_agent,
    tools=pm_tools,
    verbose=True,
    handle_parsing_errors=True,
    memory=ConversationBufferMemory(memory_key="chat_history", return_messages=True)
)

# --- 4. Simple Interaction Flow ---

async def run_simulation():
    print("--- Project Manager Simulation ---")

    # Scenario 1: Handle a new, urgent feature request
    print("\n[User Request] I need a new login system implemented ASAP. It should be assigned to Worker B.")
    await pm_agent_executor.ainvoke({"input": "Create a task to implement a new login system. It's urgent and should be assigned to Worker B."})

    print("\n" + "-"*60 + "\n")

    # Scenario 2: Handle a less urgent content update with fewer details
    print("[User Request] We need to review the marketing website content.")
    await pm_agent_executor.ainvoke({"input": "Manage a new task: Review marketing website content."})

    print("\n--- Simulation Complete ---")

# Run the simulation
if __name__ == "__main__":
    asyncio.run(run_simulation())
```

Этот код реализует простую систему управления задачами с использованием Python и LangChain, предназначенную для симуляции агента-менеджера проектов, работающего на основе большой языковой модели.

Система использует класс `SuperSimpleTaskManager` для эффективного управления задачами в памяти, применяя структуру словаря для быстрого извлечения данных. Каждая задача представлена моделью Pydantic `Task`, которая включает такие атрибуты, как уникальный идентификатор, описательный текст, необязательный уровень приоритета (P0, P1, P2) и необязательное назначение исполнителя. Использование памяти варьируется в зависимости от типа задач, количества работников и других факторов. Менеджер задач предоставляет методы для создания задач, их модификации и получения всех задач.

Агент взаимодействует с менеджером задач через определенный набор инструментов. Эти инструменты облегчают создание новых задач, назначение приоритетов задачам, распределение задач персоналу и вывод списка всех задач. Каждый инструмент инкапсулирован для обеспечения взаимодействия с экземпляром `SuperSimpleTaskManager`. Модели Pydantic используются для определения необходимых аргументов инструментов, обеспечивая валидацию данных.

`AgentExecutor` настроен с языковой моделью, набором инструментов и компонентом памяти разговора для поддержания контекстуальной непрерывности. Определен специальный `ChatPromptTemplate` для направления поведения агента в его роли управления проектами. Prompt инструктирует агента начинать с создания задачи, затем назначать приоритет и персонал согласно указаниям, и завершать полным списком задач. Назначения по умолчанию, такие как приоритет P1 и 'Worker A', предусмотрены в prompt для случаев, когда информация отсутствует.

Код включает асинхронную функцию симуляции (`run_simulation`) для демонстрации операционных возможностей агента. Симуляция выполняет два различных сценария: управление срочной задачей с назначенным персоналом и управление менее срочной задачей с минимальным вводом. Действия агента и логические процессы выводятся в консоль благодаря активации `verbose=True` в `AgentExecutor`.

## Краткий обзор

**Что:** AI агенты, работающие в сложных средах, сталкиваются с множеством потенциальных действий, конфликтующими целями и ограниченными ресурсами. Без четкого метода определения следующего шага эти агенты рискуют стать неэффективными и нерезультативными. Это может привести к значительным операционным задержкам или полной неспособности выполнить основные цели. Основная проблема заключается в управлении этим огромным количеством вариантов выбора для обеспечения целенаправленного и логичного действия агента.

**Почему:** Шаблон приоритизации предоставляет стандартизированное решение этой проблемы, позволяя агентам ранжировать задачи и цели. Это достигается путем установления четких критериев, таких как срочность, важность, зависимости и стоимость ресурсов. Агент затем оценивает каждое потенциальное действие против этих критериев для определения наиболее критического и своевременного курса действий. Эта агентная способность позволяет системе динамически адаптироваться к изменяющимся обстоятельствам и эффективно управлять ограниченными ресурсами. Сосредоточившись на элементах наивысшего приоритета, поведение агента становится более интеллектуальным, устойчивым и согласованным с его стратегическими целями.

**Эмпирическое правило:** Используйте шаблон приоритизации, когда агентная система должна автономно управлять множественными, часто конфликтующими задачами или целями в условиях ресурсных ограничений для эффективной работы в динамической среде.

**Визуальное резюме:**

![][image1]

Рис.1: Шаблон проектирования приоритизации

## Ключевые выводы

- Приоритизация позволяет AI агентам эффективно функционировать в сложных, многогранных средах.
- Агенты используют установленные критерии, такие как срочность, важность и зависимости, для оценки и ранжирования задач.
- Динамическая реприоритизация позволяет агентам корректировать свой операционный фокус в ответ на изменения в реальном времени.
- Приоритизация происходит на различных уровнях, охватывая общие стратегические цели и непосредственные тактические решения.
- Эффективная приоритизация приводит к повышению эффективности и улучшению операционной устойчивости AI агентов.

## Заключения

В заключение, шаблон приоритизации является краеугольным камнем эффективного агентного AI, оснащая системы способностью навигировать в сложностях динамических сред с целенаправленностью и интеллектом. Он позволяет агенту автономно оценивать множество конфликтующих задач и целей, принимая обоснованные решения о том, где сосредоточить свои ограниченные ресурсы. Эта агентная способность выходит за рамки простого выполнения задач, позволяя системе действовать как проактивный, стратегический принимающий решения субъект. Взвешивая такие критерии, как срочность, важность и зависимости, агент демонстрирует сложный, человекоподобный процесс рассуждения.

Ключевой особенностью этого агентного поведения является динамическая реприоритизация, которая предоставляет агенту автономию адаптировать свой фокус в реальном времени по мере изменения условий. Как показано в примере кода, агент интерпретирует неоднозначные запросы, автономно выбирает и использует подходящие инструменты и логически упорядочивает свои действия для достижения целей. Эта способность к самоуправлению рабочим процессом отличает истинную агентную систему от простого автоматизированного скрипта. В конечном счете, овладение приоритизацией является основополагающим для создания устойчивых и интеллектуальных агентов, способных эффективно и надежно работать в любом сложном, реальном сценарии.

## Литература

1. Examining the Security of Artificial Intelligence in Project Management: A Case Study of AI-driven Project Scheduling and Resource Allocation in Information Systems Projects; https://www.irejournals.com/paper-details/1706160

2. AI-Driven Decision Support Systems in Agile Software Project Management: Enhancing Risk Mitigation and Resource Allocation; https://www.mdpi.com/2079-8954/13/3/208

[image1]: ../Assets/chapter-20-image1.png

---

## Навигация

**Назад:** [Глава 19. Оценка и мониторинг](Глава%2019.%20Оценка%20и%20мониторинг.md)  
**Вперед:** [Глава 21. Исследование и открытие](Глава%2021.%20Исследование%20и%20открытие.md)
